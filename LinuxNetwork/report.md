
<a name="Contents"></a> 
#### Оглавление

- [Part 1. Инструмент ipcalc](#Part 1)
- [Part 2. Статическая маршрутизация между двумя машинами](#Part 2)
- [Part 3. Утилита iperf3](#Part 3)
- [Part 4. Сетевой экран](#Part 4)
- [Part 5. Статическая маршрутизация сети](#Part 5)
- [Part 6. Динамическая настройка IP с помощью DHCP](#Part 6)
- [Part 7. NAT](#Part 7)
- [Part 8. Дополнительно. Знакомство с SSH Tunnels](#Part 8)


<a name="Part 1"></a> 
## Part 1. Инструмент ipcalc

Поднимаем виртуальную машину ws1 и устанавливаем инсструмент ipcalc:

![linux](/LinuxNetwork/images/1-0.png)

### 1.1. Сети и маски
По заданию определяем:

1) Адрес сети 192.167.38.54/13 - 192.160.0.0/13

![linux](/LinuxNetwork/images/1-1-1.png)

2) Перевод масок:

- 255.255.255.0 в префиксную запись - /24, в двоичную запись - 11111111.11111111.11111111.00000000

- /15 в обычную запись - 255.254.0.0, двоичную запись - 11111111.11111110.00000000.00000000

- 11111111.11111111.11111111.11110000 в обычную запись  - 255.255.255.240, в префиксную запись - /28


3) Минимальный и максимальный хост в сети 12.167.38.4 при масках: 

- /8: 12.0.0.1 - 12.255.255.254

- 11111111.11111111.00000000.00000000: 12.167.0.1 - 12.167.255.254

- 255.255.254.0: 12.167.38.1 - 12.167.38.254

- /4: 0.0.0.1 - 15.255.255.254

![linux](/LinuxNetwork/images/1-1-3.png)


### 1.2. localhost

Определить, можно ли обратиться к приложению, работающему на localhost, со следующими IP: 194.34.23.100, 127.0.0.2, 127.1.0.1, 128.0.0.1.

Используем команду `ipcalc <IP-address> | grep Hosts/Net` (если в строке "Hosts/Net" есть надпись "Loopback" - обратиться можно): 

![linux](/LinuxNetwork/images/1-3-2.png)

Можно: 127.0.0.2, 127.1.0.1.

Нельзя: 194.34.23.100, 128.0.0.1.


### 1.3. Диапазоны и сегменты сетей

Определить:

1) Какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1 ?

Частные IP-адреса имеют следющий диапазон значений: 10.0.0.0 – 10.255.255.255, 172.16.0.0 – 172.31.255.255, 192.168.0.0 – 192.168.255.255, 100.64.0.0 – 100.127.255.255 (можно проверить командой `ipcalc <IP-address> | grep Hosts/Net`):

![linux](/LinuxNetwork/images/1-3-1.png)

Публичные:

- 134.43.0.2

- 172.0.2.1

- 192.172.0.1

- 172.68.0.2

- 192.169.168.1


Частные: 

- 10.0.0.45

- 192.168.4.2

- 172.20.250.4

- 172.16.255.255

- 10.10.10.10

2) Какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255 ?

Проверяем командой `ipcalc 10.10.0.0/18` :

![linux](/LinuxNetwork/images/1-3-2.png)

Ответ:

- 10.10.0.2

- 10.10.10.10

- 10.10.1.255




[-> К оглавлению](#Contents)

<a name="Part 2"></a> 
## Part 2. Статическая маршрутизация между двумя машинами

Поднимаем две виртуальные машины ws1 и ws2. Зходим в нстройки виртульной машины, раздел сеть, выбираем Адаптер 2, настраиваем его на внутреннюю сеть и даем имя, которе будет такое же, как и у ws2, мас-адреса далжны быть разные. Делаем налогично для ws2.

![linux](/LinuxNetwork/images/2-0-1.png)

С помощью команды `ip a` смотрим существующие сетевые интерфейсы для каждой из машин:

![linux](/LinuxNetwork/images/2-0-2.png)

Для того, чтобы задть адреса и маски, необходимо отредактировать файл конфигурации netplan командой `sudo vim /etc/netplan/00-installer-config.yaml`.

Файл /etc/netplan/00-installer-config на ws1:

![linux](/LinuxNetwork/images/2-0-3.png)

Файл /etc/netplan/00-installer-config на ws2:

![linux](/LinuxNetwork/images/2-0-33.png)

Далее выполняем команду `netplan apply` для перезапуска сервиса сети на обоих машинах.

![linux](/LinuxNetwork/images/2-0-4.png)



### 2.1. Добавление статического маршрута вручную

Добавляем статический маршрут от одной машины до другой и обратно при помощи команды вида `ip r add`:

![linux](/LinuxNetwork/images/2-1-1.png)


Пропинговываем соединение между машинами командой `ping -c 5` (флаг -с указывает кол-во пакетов):

![linux](/LinuxNetwork/images/2-1-2.png)

0% пакетов потеряно, соединение есть.

### 2.2. Добавление статического маршрута с сохранением

Перезагружаем машины командой `reboot`. Наши статические маршруты будут сброшены. Для их сохранения необходимо их добавить с помощью файла `etc/netplan/00-installer-config.yaml`. Открываем и редактируем его:

![linux](/LinuxNetwork/images/2-2-1.png)

Далее выполняем команду `netplan apply` для перезапуска сервиса сети на обоих машинах и проверям соединение с помощью `ping`:

![linux](/LinuxNetwork/images/2-2-2.png)

0% пакетов потеряно, соединение есть.

[-> К оглавлению](#Contents)

<a name="Part 3"></a> 
## Part 3. Утилита iperf3

Утилита iperf - это генератор сетевого трафика, предназначенный для проверки скорости и пропускной способности сети. Программа кроссплатформена, и распространяется с открытым исходным кодом.

Устанавливаем утилиту с помощью команды `sudo apt install iperf3`.

### 3.1. Скорость соединения

Перевести и записать в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps

-  8 Mbps (мегабит в секунду) = 1 MB /s (мегабайт в секунду)

- 100 MB/s (мегабайт в секунду) = 800000 Kbps (килобит в секунду)

- 1 Gbps (гигабит в секунду) = 1024 Mbps (мегабит в секунду)

### 3.2. Утилита iperf3

Чтобы проверить пропускную способность сети, нам необходимо сначала запустить iperf3 в режиме сервера с использованием флага -s, по умолчанию он будет прослушивать порт 5201:

![linux](/LinuxNetwork/images/3-2-1.png)

Запускаем iperf3 на ws2 с флагом -с в режиме клиента с указанием адреса:

![linux](/LinuxNetwork/images/3-2-2.png)

[-> К оглавлению](#Contents)


<a name="Part 4"></a> 
## Part 4. Сетевой экран

### 4.1. Утилита iptables

iptables — это утилита брандмауэра командной строки, которая использует цепочки политик для разрешения или блокировки трафика.
Когда соединение пытается установиться в вашей системе, iptables ищет в своем списке правило, которому оно соответствует.
Если он его не находит, он прибегает к действию по умолчанию. В фильтре iptables все пакеты делятся на 5 видов цепочек:

- PREROUTING — предназначена для первичной обработки входящих пакетов, адресованных как непосредственно серверу, так и другим узлам сети. Сюда попадает абсолютно весь входящий трафик для дальнейшего анализа.

- INPUT — для входящих пакетов, отправленных непосредственно этому серверу.

- FORWARD — для проходящих пакетов, не адресованных этому компьютеру, предназначены для передачи следующему узлу, в случае, если сервер выполняет роль маршрутизатора.

- OUTPUT — для пакетов, отправленных с этого сервера.

- POSTROUTING — здесь оказываются пакеты, предназначенные для передачи на другие узлы сети.

Для каждого типа пакетов можно установить набор правил, которые по очереди будут проверяться на соответствие с пакетом и если пакет соответствует, то применять к нему указанное в правиле действие. Правила образуют цепочку, поэтому input, output и forward называют цепочками, цепочками правил. Действий может быть несколько:

- ACCEPT - разрешить прохождение пакета дальше по цепочке правил;

- DROP - удалить пакет;

- REJECT - отклонить пакет, отправителю будет отправлено сообщение, что пакет был отклонен;

- LOG - сделать запись о пакете в лог файл;

- QUEUE - отправить пакет пользовательскому приложению.


В netfilter существуют 5 типов таблиц, каждая из них имеет свое назначение. Имена таблиц принято писать строчными буквами.

- raw - Содержит цепочки PREROUTING и OUTPUT, здесь производятся манипуляции с пакетами до задействования механизма определения состояний.

- mangle - Предназначена для модификации заголовков сетевых пакетов, таких параметров как ToS (Type of Service), TTL (Time To Live), MARK. Содержит все существующие пять цепочек.

- nat - Используется для трансляции сетевых адресов, т.е. подмены адреса получателя/отправителя, применяется, если сервер используется в качестве маршрутизатора. Содержит цепочки PREROUTING, OUTPUT, POSTROUTING.

- filter - Основная таблица, служит для фильтрации пакетов, именно здесь происходит принятие решений о разрешении или запрете дальнейшего движения пакета в системе. Используется по умолчанию, если явно не указано имя другой таблицы. Содержит цепочки INPUT, FORWARD и OUTPUT.

- security - Используется для взаимодействия с внешними системами безопасности, в частности с SELinux и AppArmor. Содержит цепочки INPUT, OUTPUT и FORWARD.



Устнавливаем утилиту командой `sudo apt install iptables`.

Создаём файл `/etc/firewall.sh`, имитирующий фаерволл, на ws1 и ws2 и редактируем по заданию:

![linux](/LinuxNetwork/images/4-1-1.png)

Команда -F (-flush) удаляет все правила, команда -X (-delete-chain) удаляет пользовательскую цепочку, команда -A (-append) добавляет правило в конец указанной цепочки, -p указывет используемый протокол (tcp или icmp), -j означает, когда правило подошло — выполнить указанное действие. --dport - порт для получения пакетов, --sport - порт для отправки пакетов. Эхо-запросы (Echo Request) и эхо-ответы (Echo Reply) применяются для проверки активности системы. 

Запускаем файлы на обеих машинах командами `chmod +x /etc/firewall.sh` (chmod +x дает права на выполнение) и `/etc/firewall.sh`:

![linux](/LinuxNetwork/images/4-1-2.png)

Разница между стратегиями, применёнными в первом и втором файлах заключается в порядке команд, если в начале идет запрещающее правило, то далее оно не перезаписывается разрешающим правилом, получаем, что ws1 отклоняет пакеты, а ws2 разрешает им проходить.




### 4.2. Утилита nmap

Пингуем наши машины:

![linux](/LinuxNetwork/images/4-2-1.png)

Не пингуется ws1. Утилитой nmap проверяем, запущен ли хост машины:

![linux](/LinuxNetwork/images/4-2-2.png)

Видим, что с ws2 показывает, что ws1 запущена.

<a name="dumps-instruction"></a> 
Сохраняем дампы образов виртуальных машин:

- Включаем отображение "снимков" в VirtualBox:
![linux](/LinuxNetwork/images/4-2-3.png)

- Сохраняем дамп и задаем ему имя:
![linux](/LinuxNetwork/images/4-2-4.png)

- Аналогично для ws2, путь к дампу указан внизу в свойствах:
![linux](/LinuxNetwork/images/4-2-5.png)

[-> К оглавлению](#Contents)



<a name="Part 5"></a> 
## Part 5. Статическая маршрутизация сети
Поднимаем пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2), для изменения названий машин использовалась команда `sudo hostnamectl set-hostname <новое_имя>`, также в VirtualBox указано нужное количество сетевых адаптеров на каждой машине). 

Схема сети:

![linux](/misc/images/part5_network.png)

### 5.1. Настройка адресов машин

Необходимо настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.

Для начала необходимо переименовать сетевые интерфейсы согласно схеме, для этого понадобиться MAC-адрес сетевого адаптера, его можно узнать через VirtualBox, либо командой `sudo ifconfig -a`, после в файле `etc/netplan/00-installer-config.yaml` указать MAC-адрес и новое название, 

![linux](/LinuxNetwork/images/5-1-1.png)

После редактирования файл `etc/netplan/00-installer-config.yaml` название сетевого интерфейса изменилось, можно проверить ещё одной командой `ip link show`, MAC-адрес тот же:

![linux](/LinuxNetwork/images/5-1-1-b.png)

Файл `etc/netplan/00-installer-config.yaml` на ws11, ws21, ws22:

![linux](/LinuxNetwork/images/5-1-2-ws.png)

Файл `etc/netplan/00-installer-config.yaml` на r1, r2:

![linux](/LinuxNetwork/images/5-1-2-r.png)



Не забываем на всех машинах применить команду `sudo netplan apply`:

![linux](/LinuxNetwork/images/5-1-2-apply.png)

Проверяем изменения командой `ip -4 a` (-4 то же, что и -f inet, выбирает протокол, a - показывает адреса):

![linux](/LinuxNetwork/images/5-1-total.png)

Для проверки пингуем ws21 c ws22:

![linux](/LinuxNetwork/images/5-1-ws-ping.png)

Для проверки пингуем  r1 с ws11:

![linux](/LinuxNetwork/images/5-1-r1-ws11-ping.png)


### 5.2. Включение переадресации IP-адресов.

Для включения переадресации IP на роутерах выполним команду `sysctl -w net.ipv4.ip_forward=1`:

![linux](/LinuxNetwork/images/5-2-1.png)

При таком подходе переадресация не будет работать после перезагрузки системы. Тогда откроем файл `/etc/sysctl.conf` и добавим в него следующую строку: `net.ipv4.ip_forward = 1`. При использовании этого подхода, IP-переадресация включена на постоянной основе.

Файл `/etc/sysctl.conf` на r1:

![linux](/LinuxNetwork/images/5-2-2-r1.png)

Файл `/etc/sysctl.conf` на r2:

![linux](/LinuxNetwork/images/5-2-2-r2.png)


### 5.3. Установка маршрута по-умолчанию

Настроить маршрут по-умолчанию (шлюз) для рабочих станций можно добавив в yaml-файл строку `gateway4: <address>`, однако такой способ считается устраевшим, используем другой вариант(`routes`), указанный на скриншотах.

Файл `etc/netplan/00-installer-config.yaml` на ws11:

![linux](/LinuxNetwork/images/5-3-1-ws11.png)

Файл `etc/netplan/00-installer-config.yaml` на ws21:

![linux](/LinuxNetwork/images/5-3-1-ws21.png)

Файл `etc/netplan/00-installer-config.yaml` на ws22:

![linux](/LinuxNetwork/images/5-3-1-ws22.png)

После на всех рабочих станциях вызываем `netply apply` и `ip r`, чтобы показать, что добавился маршрут в таблицу маршрутизации:

![linux](/LinuxNetwork/images/5-3-2.png)

Далее для пингуем с ws11 роутер r2:

![linux](/LinuxNetwork/images/5-3-3.png)

На самом деле на r2 что пинг доходит (подробнее в пункте 5.4), убеждаемся в этом, используя команду `tcpdump -tn -i eth1` :

![linux](/LinuxNetwork/images/5-3-4.png)


### 5.4. Добавление статических маршрутов

Необходимо добавить в роутеры r1 и r2 статические маршруты в файле конфигураций.

Файл `etc/netplan/00-installer-config.yaml` на r1:

![linux](/LinuxNetwork/images/5-4-1.png)

Файл `etc/netplan/00-installer-config.yaml` на r2:

![linux](/LinuxNetwork/images/5-4-2.png)

Вызываем `netplan apply` и `ip r`, чтобы показать таблицы с маршрутами на обоих роутерах:

![linux](/LinuxNetwork/images/5-4-3.png)

Далее на ws11 запускаем команды `ip r list 10.10.0.0/[маска сети]` и `ip r list 0.0.0.0/0` :

![linux](/LinuxNetwork/images/5-4-4.png)

Для адреса 10.10.0.0/[маска сети] был выбран маршрут, отличный от 0.0.0.0/0, хотя он попадает под маршрут по-умолчанию, потому что адрес 0.0.0.0/0 «без конкретного адреса назначения», т.е он соответствует любому адресу.

Проще говоря, IP-адрес 0.0.0.0 означает "эта сеть", но он не является полезным адресом в традиционном смысле. Он немного похож на записку, в которой говорится: "Вставьте адрес здесь" или, в зависимости от контекста, "нет конкретного адреса назначения". Он действует как запасной вариант до тех пор, пока не будет назначен действительный, маршрутизируемый IP-адрес.


### 5.5. Построение списка маршрутизаторов

Запускаем на r1 команду `tcpdump -tnv -i eth0`. При помощи утилиты `traceroute` нужно построить список маршрутизаторов на пути от ws11 до ws21, вводим комнаду `traceroute <IP ws21>`:

![linux](/LinuxNetwork/images/5-5-1.png)

Вывод команды `tcpdump -tnv -i eth0` на r1 после выше сделнного действия:

![linux](/LinuxNetwork/images/5-5-2.png)

Принцип работы построения пути при помощи traceroute:

Каждый пакет проходит на своем пути определенное количество узлов, пока достигнет своей цели. Причем, каждый пакет имеет свое время жизни. Это количество узлов, которые может пройти пакет перед тем, как он будет уничтожен. Этот параметр записывается в заголовке TTL, каждый маршрутизатор, через который будет проходить пакет уменьшает его на единицу. При TTL=0 пакет уничтожается, а отправителю отсылается сообщение Time Exceeded.

Команда traceroute linux использует UDP пакеты. Она отправляет пакет с TTL=1 и смотрит адрес ответившего узла, дальше TTL=2, TTL=3 и так пока не достигнет цели. Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят. Когда утилита traceroute получает сообщение от целевого узла о том, что порт недоступен трассировка считается завершенной.


### 5.6. Использование протокола ICMP при маршрутизации

Запускаем на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды `tcpdump -n -i eth0 icmp` :

![linux](/LinuxNetwork/images/5-6-1.png)

Пытаемся пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды `ping -c 1 10.30.0.111` :

![linux](/LinuxNetwork/images/5-6-2.png)

[-> К оглавлению](#Contents)




<a name="Part 6"></a> 
## Part 6. Динамическая настройка IP с помощью DHCP

Для r2 необходимо настроить в файле `/etc/dhcp/dhcpd.conf` конфигурацию службы DHCP:

![linux](/LinuxNetwork/images/6-1.png)

В файле resolv.conf также прописать nameserver 8.8.8.8:

![linux](/LinuxNetwork/images/6-2.png)

Перезагружаем службу DHCP командой `systemctl restart isc-dhcp-server` :

![linux](/LinuxNetwork/images/6-3.png)

Далее перезагружаем машину ws21 при помощи `reboot` (в файле  `etc/netplan/00-installer-config.yaml` не забываем изменить `dhcp4` на `true` и применить `netplan apply`) и вводим `ip a`. После чего пингуем ws22 с ws21:

![linux](/LinuxNetwork/images/6-4.png)

Новый адрес получен, пакеты доходят.

Далее нужно указать MAC адрес у ws11, для этого в `etc/netplan/00-installer-config.yaml` надо добавить строки: `macaddress: 10:10:10:10:10:BA`, `dhcp4: true`. 


Но перед эти необходимо изменить MAC-адресс на самом сетевом интерфейсе. Для этого вводим следующие команды (отключаем сетевой интерфейс, изменяем MAC-адрес, включаем обратно):

![linux](/LinuxNetwork/images/6-mac.png)

И проверяем с помощью `ip a`, адрес изменился.


Вариант 2, в VirtualBox изменить MAC-адрес как в задании, для этого выключаем машину и заходим в настройки:

![linux](/LinuxNetwork/images/6-5.png)

Далее редактируем файл `etc/netplan/00-installer-config.yaml` на ws11:

![linux](/LinuxNetwork/images/6-6.png)



После чего приступаем к настройке r1, аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11).


Настраиваем в файле `/etc/dhcp/dhcpd.conf` конфигурацию службы DHCP для r1:

![linux](/LinuxNetwork/images/6-r2-1.png)

В файле `resolv.conf` на r1 прописываем `nameserver 8.8.8.8`:

![linux](/LinuxNetwork/images/6-r2-2.png)

Перезагружаем службу DHCP командой `systemctl restart isc-dhcp-server` и проверим `systemctl status isc-dhcp-server` :

![linux](/LinuxNetwork/images/6-r2-3.png)

Вводим `ip a` на ws11 ДО и ПОСЛЕ (разделяющая зеленая черта) настройки r1:

![linux](/LinuxNetwork/images/6-r2-4.png)

Видим, что на ws11 был получен новый IP-адрес. Для проверки пингуем с ws11 до ws21, ws22, потом с ws21 до ws11:

![linux](/LinuxNetwork/images/6-r2-5.png)


Далее по заданию необходимо запросить с ws21 обновление ip адреса. Нужно освободить старый IP-адресс, после получить новый, командой `ip a` смотрим адрес до и после:

![linux](/LinuxNetwork/images/6-ws21-new-ip.png)

Следющие опции DHCP сервера были использованы в данном пункте:

- Настройка конфигурации службы DHCP (адрес маршрутизатора по-умолчанию, DNS-сервер, адрес внутренней сети, привязка к MAC-адресу):

- range <IP start> <IP end>; - диапазон доступных IP адресов

- option routers 10.10.0.1; - адрес шлюза маршрутизатора

- option domain-name-servers 10.10.0.1; - IP адрес DNS-сервера

- hardware ethernet: <MAC-address>; - привязка по MAC-адресу

- fixed-address: <IP-address>; - назначение определённого IP адреса


- Клиент протокола динамической конфигурации хоста (команда `dhclient`) для освобождения и обновления IP-адреса.


В заключение этого пунтка сохраняем дампы образов виртуальных машин (действия описаны [в конце пункта 4.2](#dumps-instruction)):

![linux](/LinuxNetwork/images/6-dumps.png)

[-> К оглавлению](#Contents)



<a name="Part 7"></a> 
## Part 7. NAT


Необходмио сделать сервер Apache2 общедоступным, для этого нужно в файле `/etc/apache2/ports.conf`  изменить строку `Listen 80` на `Listen 0.0.0.0:80`.


Содержимое файла `/etc/apache2/ports.conf` на ws22:

![linux](/LinuxNetwork/images/7-1.png)

Содержимое файла `/etc/apache2/ports.conf` на r1:

![linux](/LinuxNetwork/images/7-2.png)

Запускаем веб-сервер Apache командой `service apache2 start` на ws22 и r1:

![linux](/LinuxNetwork/images/7-3.png)



Далее по заданию добавляем в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:

1) удаление правил в таблице filter - iptables -F

2) удаление правил в таблице "NAT" - iptables -F -t nat

3) отбрасывать все маршрутизируемые пакеты - iptables --policy FORWARD DROP

После чего запускасем его командами `sudo chmod +x /etc/firewall.sh` и `sudo /etc/firewall.sh` :

![linux](/LinuxNetwork/images/7-4.png)

Проверяем соединение между ws22 и r1 командой `ping` :

![linux](/LinuxNetwork/images/7-5.png)

При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1.

Добавляем в файл `/etc/firewall.sh` на r2 ещё одно правило и также запустить файл: 

4) разрешить маршрутизацию всех пакетов протокола ICMP:

![linux](/LinuxNetwork/images/7-6.png)

Проверяем соединение между ws22 и r1 командой `ping` :

![linux](/LinuxNetwork/images/7-7.png)

При запуске файла с этими правилами, ws22 должна "пинговаться" с r1.

Добавляем в файл `/etc/firewall.sh` на r2 ещё два правила:

5) включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)

6) включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети


Содержимое файла `/etc/firewall.sh` на r2:

![linux](/LinuxNetwork/images/7-8.png)


Запускаем файл и проверяем соединение по TCP для SNAT, для этого с ws22 подключяемся к серверу Apache на r1 командой `telnet 10.100.0.11 80` :

![linux](/LinuxNetwork/images/7-9.png)

Проверяем соединение по TCP для DNAT, для этого с r1 подключаемся к серверу Apache на ws22 командой `telnet` (обращаемся по адресу r2 и порту 8080) :

![linux](/LinuxNetwork/images/7-10.png)


[-> К оглавлению](#Contents)



<a name="Part 8"></a> 
## Part 8. Дополнительно. Знакомство с SSH Tunnels

SSH туннели один из самых часто используемых методов связи среди системных и сетевых администраторов. В данном руководстве расскажем о такой функции как переброс порта SSH. Это используется для безопасной передачи данных между двумя и более системами.

Запускаем на r2 фаервол с правилами из Части 7.

Содержимое файла `/etc/firewall.sh` на r2 :

![linux](/LinuxNetwork/images/7-8.png)

Запускаем с помощью команд `sudo chmod +x /etc/firewall.sh` и `sudo /etc/firewall.sh`

![linux](/LinuxNetwork/images/8-2.png)

Запускаем веб-сервер Apache на ws22 только на localhost (то есть в файле `/etc/apache2/ports.conf` изменить строку `Listen 80` на `Listen localhost:80`)

![linux](/LinuxNetwork/images/8-3.png)

Воспользуемся Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21 (-L означает, что мы запускаем проброс локального порта):

![linux](/LinuxNetwork/images/8-4.png)

Воспользуемся Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11 :

![linux](/LinuxNetwork/images/8-5.png)

Для проверки, сработало ли подключение в обоих предыдущих пунктах, переходим во второй терминал (клавишами Alt + F2) и выполняем команду `telnet 127.0.0.1 [локальный порт]`.

На ws11:

![linux](/LinuxNetwork/images/8-6.png)

На ws21:

![linux](/LinuxNetwork/images/8-7.png)


[-> К оглавлению](#Contents)
